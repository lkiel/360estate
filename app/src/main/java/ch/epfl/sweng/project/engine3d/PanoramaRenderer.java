package ch.epfl.sweng.project.engine3d;


import android.content.Context;
import android.hardware.Sensor;
import android.hardware.SensorManager;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.MotionEvent;

import org.rajawali3d.cameras.Camera;
import org.rajawali3d.materials.Material;
import org.rajawali3d.materials.textures.ATexture;
import org.rajawali3d.materials.textures.Texture;
import org.rajawali3d.math.Quaternion;
import org.rajawali3d.math.vector.Vector3;
import org.rajawali3d.primitives.Sphere;
import org.rajawali3d.renderer.Renderer;

import ch.epfl.sweng.project.BuildConfig;
import ch.epfl.sweng.project.R;

import static android.content.Context.SENSOR_SERVICE;

/**
 * This class defines how the 3d engine should be used to
 * render the scene.
 */
public class PanoramaRenderer extends Renderer {

    public static final double SENSITIVITY = 100.0;
    public static final double MAX_PHI = 2 * Math.PI;
    public static final double EPSILON = 0.1d;
    public static final double MAX_THETA = Math.PI - EPSILON;


    private final String TAG = "Renderer";
    private final Camera mCamera;
    private final Vector3 mInitialPos;
    private final Vector3 mInitialLookat;
    private final double mXdpi;
    private final double mYdpi;
    private final SensorManager mSensorManager;
    private final RotSensorListener mRotListener;
    private final boolean mRotSensorAvailable;
    private final Sensor mRotSensor;
    private Sphere mChildSphere = null;
    private Quaternion mUserRot;
    private Quaternion mSensorRot;

    public PanoramaRenderer(Context context) {

        super(context);

        mSensorManager = (SensorManager) context.getSystemService(SENSOR_SERVICE);
        Sensor rotSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_GAME_ROTATION_VECTOR);

        if (rotSensor == null) {
            if (BuildConfig.DEBUG) {
                Log.d(TAG, "No rotSensor available");
            }
            mRotListener = null;
            mRotSensor = null;
            mRotSensorAvailable = false;
        } else {
            mRotListener = new RotSensorListener(this, mSensorManager);
            mRotSensor = rotSensor;
            mRotSensorAvailable = true;
        }


        mContext = context;

        DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics();
        mXdpi = displayMetrics.xdpi;
        mYdpi = displayMetrics.ydpi;

        mUserRot = new Quaternion();
        mSensorRot = new Quaternion();
        mCamera = getCurrentCamera();
        mCamera.setFieldOfView(80);

        setFrameRate(60);

        mInitialPos = new Vector3(0, 0, 0);
        mInitialLookat = new Vector3(0, 0, -1);
    }

    @Override
    public void onResume() {
        super.onResume();
        if (mRotSensorAvailable) {
            mSensorManager.registerListener(mRotListener, mRotSensor, SensorManager.SENSOR_DELAY_GAME);
        }
    }

    @Override
    public void onPause() {
        super.onPause();
        if (mRotSensorAvailable) {
            mSensorManager.unregisterListener(mRotListener);
        }
    }


    @Override
    public void initScene() {

        Log.d(TAG, "Initializing scene");

        mCamera.setPosition(mInitialPos);
        mCamera.setLookAt(mInitialLookat);

        Material material = new Material();
        Material material2 = new Material();
        material.setColor(0);
        material2.setColor(0);

        Texture earthTexture = new Texture("Earth", R.drawable.pano_1024);
        Texture earthTexture2 = new Texture("Earth", R.drawable.earthtruecolor_nasa_big);
        earthTexture.shouldRecycle(true);
        earthTexture2.shouldRecycle(true);

        try {
            material.addTexture(earthTexture);
            material2.addTexture(earthTexture2);

        } catch (ATexture.TextureException error) {
            if (BuildConfig.DEBUG) {
                Log.d(TAG, error.toString());
            }
        }

        mChildSphere = new Sphere(8, 10, 10);
        mChildSphere.setMaterial(material2);
        mChildSphere.setZ(50);
        Sphere earthSphere = new Sphere(100, 48, 48);
        earthSphere.addChild(mChildSphere);
        earthSphere.setPosition(mInitialPos);
        earthSphere.setBackSided(true);
        earthSphere.setMaterial(material);

        getCurrentScene().addChild(earthSphere);
    }

    /**
     * Method currently not used as the panorama renderer activity already implements an
     * onTouchListener
     *
     * @param event the MotionEvent generated by the user
     */
    @Override
    public void onTouchEvent(MotionEvent event) {
    }

    /**
     * Method not used
     *
     * @param x .
     * @param y .
     * @param z .
     * @param w .
     * @param i .
     * @param j .
     */
    @Override
    public void onOffsetsChanged(float x, float y, float z, float w, int i, int j) {
    }


    @Override
    public void onRender(final long elapsedTime, final double deltaTime) {
        super.onRender(elapsedTime, deltaTime);

        mChildSphere.rotate(Vector3.Axis.Y, 0.4);
        updateCamera();
    }

    /**
     * Use this method to rotate the camera according to the user input.
     * Its parameters represent over how much pixels the user has dragged its
     * fingers. Positive dx means gesture going to the right, positive dy means
     * gesture going down the screen.
     * The actual angle change is then proportional to the screen dpi so the
     * effect of a "swipe" doesn't change depending on the user screen resolution.
     *
     * @param dx The difference in pixels along the X axis. Positive means right
     * @param dy The difference in pixels along the Y axis. Positive means down
     */
    public void updateCameraRotation(float dx, float dy) {
        double phi = (dx / mXdpi) * SENSITIVITY;

        Quaternion rotY = new Quaternion().fromAngleAxis(Vector3.Axis.Y, -phi);
        mUserRot.multiply(rotY);
    }

    /**
     * This method should be called by the sensor listener in order to inform the renderer
     * of the current device rotation
     *
     * @param q The quaternion representing the device's rotation
     */
    public void setSensorRotation(Quaternion q) {
        mSensorRot = new Quaternion(q);
    }

    /**
     * Updates the camera rotation based on user input and sensor information if available.
     * The way the camera rotation works is the following:
     * <p>
     * The class keeps track of a user quaternion which at the beginning is the identity quaternion.
     * The user quaternion cumulates the inputs generated by the user when the latter touches his screen.
     * Then, periodically the sensor listener updates the mSensorRot field with the latest values.
     * The camera rotation is then given by the sensor rotation additioned with the user input.
     * In quaternion notation this is equivalent to multiplying the sensor quaternion by the user
     * quaterion. Note that a defensive copy is needed because quaternions are mutable objects.
     * </p>
     */
    private void updateCamera() {
        Quaternion q = new Quaternion(mSensorRot);
        mCamera.setCameraOrientation(q.multiply(mUserRot));
    }

}
